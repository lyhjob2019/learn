// 递归
// 递归简而言之就是一个函数调用本身或者两个函数相互调用
// 我们只讨论第一种情况
// 需要注意的是，递归是一个比较难以理解的概念
// 看不懂，不理解，太正常了
// 这需要时间，不要急着强行非要搞懂
// 不懂这个也不影响你找工作或者工作，所以慢慢来理解
// 现在只是为了介绍这个概念，知道有这么回事就可以了


// 注意，接下来的例子都只是例子而已，实际不会这么写代码
// 递归有适用的场景，但不会用来求阶乘这样的事情
// 只是为了简化描述才用了这个例子
//
// 用递归求阶乘
//
// 阶乘的定义如下
// n! = n * (n - 1)!
// 当 n 等于 0 的时候，阶乘为 1（不要问为什么，这是规定）
// 所以可以用递归编写下面的代码
const fac = function(n) {
    // 如果 n 是 0 则返回 1
    // 这是递归终止的条件，必须要有，否则无限递归了
    if (n == 0) {
        return 1
    } else {
        // 如果 n 不为 0，返回 n * fac(n - 1)
        // 这时候 n 是已知的，fac(n - 1) 需要计算
        // 于是代码进入下一重世界开始计算
        var n1 = fac(n - 1)
        return n * n1
    }
}
// 遇到点小问题不要想太多。这是太正常了。想太多这个想法才不正常。
// fac0 1
// fac1 1 * fac0
// fac2 2 * fac1
// fac3 3 * fac2
// fac4 4 * fac3
// fac5 5 * fac4

log('递归阶乘', fac(5))

// 运行，输出如下
// 递归阶乘 120


// 用递归求斐波那契数
//
// 斐波那契的定义如下
// fib(n) = fib(n - 2) + fib(n - 1)
// 当 n 等于 1 2 的时候, fib(n) 为 1
// 所以可以用递归编写下面的语句
const fib = function(n) {
    // 如果 n 小于 3
    // 则返回 1 作为结束
    // 这是递归终止的条件，必须要有，否则无限递归了
    if (n < 3) {
        return 1
    } else {
        // 如果 n 不为 1 和 2，返回 fib(n - 2) + fib(n - 1)
        // 这时候 fib(n - 2) fib(n - 1) 需要计算
        // 于是代码进入下一重世界开始计算
        return fib(n - 2) + fib(n - 1)
    }
}


log('递归 fib', fib(6))
log('递归 fib', fib(7))



// 运行，输出如下
// 递归 fib 8
// 递归 fib 13
